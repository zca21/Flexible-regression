---
title: "Untitled"
output: html_document
date: "2023-03-22"
---
```{r}
library(splines)
setwd("~/Desktop/Flexible Regression/CW/Flexible-regression")
marine.data <- read.csv("marine.csv")
```

```{r}
#Q1
with(marine.data,
  plot(x=depth,y=diameter,
       pch = 16, col = "#00000077"))
#relationship is non-linear...
```

```{r}
#Q2 - fitting polynomial regressions
lm2 <- lm(diameter~poly(depth,2),marine.data)
lm10 <- lm(diameter~poly(depth,10),marine.data)
lm20 <- lm(diameter~poly(depth,20),marine.data)

#plotting
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(lm2)[order(depth)],
        col = "red", lwd = 3.5)})

with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(lm10)[order(depth)],
        col = "blue", lwd = 3.5)})

with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(lm20)[order(depth)],
        col = "green", lwd = 3.5)})

#2 poly fails to capture the relationship 
#10 poly does a fairly good job at capturing trend - has squiggle at the end
#20 poly has artefacts caused by noise being captured rather than the trend (at start and end see the squiggles) [overfitting] - runges phenomenem?
```

```{r}
#Question 3
#a
bs.basis <- bs(marine.data$depth,degree=3,knots = c(10, 20, 30, 40, 60),intercept=T)

#b
bs.model <- lm(diameter ~ -1 + bs.basis, marine.data)
summary(bs.model)

#c
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(bs.model)[order(depth)],
        col = "red", lwd = 3.5)})

#d
predict.df <- data.frame(predict(bs.model, interval = 'confidence'))
#confidence interval is 2nd and 3rd value

#e
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
   lines(x=sort(depth),y = fitted(bs.model)[order(depth)],
        col = "red", lwd = 2)
   lines(x=sort(depth),y = predict.df$lwr[order(depth)],
        col = "blue", lwd = 2, lty = "dashed")
   lines(x=sort(depth),y = predict.df$upr[order(depth)],
        col = "blue", lwd = 2, lty = "dashed")})

```

```{r}
#Question 4

#As natural splines conditions free up 4 degrees of freedom means can have 4 more knots thus 2 boundary knots and 7 internal knots to maintain the same degree of freedom as the b-spline which had 5 knots

#b
ns.basis <- ns(marine.data$depth,knots = c(12.5,20,27.5,35,42.5,50,57.5),intercept=T,Boundary.knots = c(5,65))

#c
ns.model <- lm(diameter~-1+ns.basis,marine.data)
summary(ns.model)

#d
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(ns.model)[order(depth)],
        col = "red", lwd = 3.5)})

#e
predict.ns.df <- data.frame(predict(ns.model, interval = 'confidence'))
#confidence interval is 2nd and 3rd value

#f
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
   lines(x=sort(depth),y = fitted(ns.model)[order(depth)],
        col = "red", lwd = 2)
   lines(x=sort(depth),y = predict.ns.df$lwr[order(depth)],
        col = "blue", lwd = 2, lty = "dashed")
   lines(x=sort(depth),y = predict.ns.df$upr[order(depth)],
        col = "blue", lwd = 2, lty = "dashed")})

#g
#trend better at boundary, CI also smaller at boundary
```

```{r}
#Question 5

#a
ss_12.5 <- smooth.spline(x=marine.data$depth,y=marine.data$diameter,df=12.5)
ss_12.5

#b
ss_17.5 <- smooth.spline(x=marine.data$depth,y=marine.data$diameter,df=17.5)
ss_17.5

#c
ss_25 <- smooth.spline(x=marine.data$depth,y=marine.data$diameter,df=25)
ss_25

#d
with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(ss_12.5)[order(depth)],
        col = "red", lwd = 3.5)})

with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(ss_17.5)[order(depth)],
        col = "red", lwd = 3.5)})

with(marine.data,
  {plot(x=depth,y=diameter,
        pch = 16, col = "#00000077")
  lines(x=sort(depth),y = fitted(ss_25)[order(depth)],
        col = "red", lwd = 3.5)})
#over fitting seems to be happening on higher effective degree of freedom smoothing spines with noise being added to (seen by the pertubations)
```

```{r}
#Question 6

#Creating function to calculate overall cross validation error of dataset using 14 folds defined by group variable with input s.degree used to choose the splines degree 
cv.error.func <- function(s.degree){
cv.fold.error <- NULL
for (i in 1:14){
  #removing ith partition (group i) from data
  depth <- marine.data$depth[marine.data$group!=i]
  diameter <- marine.data$diameter[marine.data$group!=i]
  
  #fitting spline without ith partition
  b.spline.basis <- bs(x=depth,degree=s.degree,knots = c(15, 25, 35, 45, 55),intercept=T)
  b.spline.fitted <- lm(diameter ~ -1 + b.spline.basis)
  
  #Calculating CV error for the ith fold
  b.spline.diff <- diameter - fitted(b.spline.fitted)
  cv.fold.error[i] <- sum(b.spline.diff^2)
}
#calculating overall cv error of model
error <- sum(cv.fold.error)*1/14
return(error)
}

#calculating overall CV error for b-splines of degree 1-5
cv.error.func(1)
cv.error.func(2)
cv.error.func(3)
cv.error.func(4)
cv.error.func(5)

#As the degree 4 (order 5) spline has the lowest overall cross validation error of 165.896 this is the polynomial degree that should be selected
```


```{r}
cv.error.func <- function(s.degree){
cv.fold.error <- NULL
for (i in 1:14){
  #removing ith partition (group i) from data
  testset <- marine.data[marine.data$group==i,]
  trainset <- marine.data[marine.data$group!=i,]
  
  #fitting spline without ith partition
  b.spline.basis <- bs(x=trainset$depth,degree=s.degree,knots = c(15, 25, 35, 45, 55),intercept=T)
  b.spline.fitted <- lm(trainset$diameter ~ -1 + b.spline.basis)
  
  #predicting value using model
  predict.data <- data.frame(bs(x=testset$depth,degree=s.degree,knots = c(15, 25, 35, 45, 55),intercept=T))
  bs.fit.pred <- as.matrix(predict.data)%*%as.matrix(b.spline.fitted$coefficients)
  
  #calculating cv error for ith fold
  cv.fold.error[i] <- sum((testset$diameter-as.numeric(bs.fit.pred))^2)
}
#calculating overall cv error of model
error <- sum(cv.fold.error)/nrow(marine.data)
return(error)
}

cv.error.func(1)
cv.error.func(2)
cv.error.func(3)
cv.error.func(4)
cv.error.func(5)

#Using a spline with 4 degrees gives the lowest overall CV error, thus this is the best model out of splines using degrees 1,2,3,4 and 5. (dont know if higher order may have a better CV error)
```

```{r}
#Testing Q6 using 
bs.basis <- bs(marine.data$depth,degree=3,knots = c(10, 20, 30, 40, 60),intercept=T)

#Creating b-spline regression
bs.model <- lm(diameter ~ -1 + bs.basis, marine.data)

#Using prediction method in Q6
predict.data <- data.frame(bs(marine.data$depth,degree=3,knots = c(10, 20, 30, 40, 60),intercept=T))
bs.fit.pred <- as.matrix(predict.data)%*%as.matrix(bs.model$coefficients)

#comparing against predict function
sum(predict(bs.model)-bs.fit.pred)
```


